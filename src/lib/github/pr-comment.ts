/**
 * PR Comment Generator
 * 
 * Feature #7: PR comments with visual diffs
 * 
 * Automatically post visual diff summaries as PR comments.
 * Updates existing comments on re-runs instead of spamming.
 */

import type { ComparisonResult, VisualDifference } from '../comparison/index.js';

// ============================================================================
// Types
// ============================================================================

export interface CommentConfig {
  /** GitHub token for API calls */
  token: string;
  /** Repository owner */
  owner: string;
  /** Repository name */
  repo: string;
  /** PR number */
  prNumber: number;
  /** Include image previews (requires hosting) */
  includeImages?: boolean;
  /** URL prefix for hosted images */
  imageUrlPrefix?: string;
  /** Maximum differences to show per page */
  maxDifferencesPerPage?: number;
}

export interface PageResult {
  name: string;
  url: string;
  result: ComparisonResult;
  figmaImageUrl?: string;
  liveImageUrl?: string;
}

export interface CommentResult {
  success: boolean;
  commentId?: number;
  commentUrl?: string;
  error?: string;
}

// ============================================================================
// Comment Generator
// ============================================================================

export class PRCommentGenerator {
  private config: CommentConfig;
  private readonly COMMENT_MARKER = '<!-- parity-ux-check -->';

  constructor(config: CommentConfig) {
    this.config = {
      includeImages: false,
      maxDifferencesPerPage: 5,
      ...config,
    };
  }

  /**
   * Generate markdown comment for PR
   */
  generateComment(
    pages: PageResult[],
    passed: boolean,
    overallScore: number,
    reportUrl?: string
  ): string {
    const summary = this.calculateSummary(pages);
    const statusEmoji = passed ? 'âœ…' : 'âŒ';
    const scoreColor = this.getScoreEmoji(overallScore);

    let comment = `${this.COMMENT_MARKER}
## ${statusEmoji} Parity UX Fidelity Check

| Metric | Value |
|--------|-------|
| **Match Score** | ${scoreColor} ${overallScore}% |
| **Status** | ${passed ? 'âœ… Passed' : 'âŒ Failed'} |
| **Pages Checked** | ${pages.length} |
| **Total Issues** | ${summary.total} |

`;

    // Issue breakdown
    if (summary.total > 0) {
      comment += `### ðŸ“Š Issue Breakdown

| Severity | Count |
|----------|-------|
| ðŸ”´ Critical | ${summary.critical} |
| ðŸŸ  High | ${summary.high} |
| ðŸŸ¡ Medium | ${summary.medium} |
| âšª Low | ${summary.low} |

`;
    }

    // Per-page results
    comment += `### ðŸ“„ Page Results\n\n`;
    
    for (const page of pages) {
      const pageEmoji = this.getScoreEmoji(page.result.matchScore);
      const pageStatus = page.result.matchScore >= 85 ? 'âœ“' : 'âœ—';
      
      comment += `<details>\n`;
      comment += `<summary><strong>${pageStatus} ${page.name}</strong> â€” ${pageEmoji} ${page.result.matchScore}% (${page.result.differences.length} issues)</summary>\n\n`;
      
      comment += `**URL:** \`${page.url}\`\n\n`;

      // Image comparison if available
      if (this.config.includeImages && page.figmaImageUrl && page.liveImageUrl) {
        comment += `| Figma Design | Live Website |\n`;
        comment += `|:------------:|:------------:|\n`;
        comment += `| ![Figma](${page.figmaImageUrl}) | ![Live](${page.liveImageUrl}) |\n\n`;
      }

      // Differences
      if (page.result.differences.length > 0) {
        comment += `**Issues Found:**\n\n`;
        
        const diffsToShow = page.result.differences.slice(0, this.config.maxDifferencesPerPage);
        
        for (const diff of diffsToShow) {
          comment += this.formatDifference(diff);
        }
        
        if (page.result.differences.length > this.config.maxDifferencesPerPage!) {
          comment += `\n*... and ${page.result.differences.length - this.config.maxDifferencesPerPage!} more issues*\n`;
        }
      } else {
        comment += `âœ¨ **No issues found!**\n`;
      }

      // Annotations
      if (page.result.annotations.length > 0) {
        comment += `\n**Notes:**\n`;
        for (const annotation of page.result.annotations) {
          comment += `- ${annotation}\n`;
        }
      }

      comment += `\n</details>\n\n`;
    }

    // Report link
    if (reportUrl) {
      comment += `---\nðŸ“„ [View Full Report](${reportUrl})\n\n`;
    }

    // Footer
    comment += `---\n*Generated by [Parity](https://github.com/spencerht24/parity) â€¢ ${new Date().toISOString()}*`;

    return comment;
  }

  /**
   * Post or update comment on PR
   */
  async postComment(markdown: string): Promise<CommentResult> {
    const apiUrl = `https://api.github.com/repos/${this.config.owner}/${this.config.repo}`;
    
    try {
      // Find existing comment
      const existingComment = await this.findExistingComment();
      
      if (existingComment) {
        // Update existing comment
        const response = await fetch(`${apiUrl}/issues/comments/${existingComment.id}`, {
          method: 'PATCH',
          headers: {
            'Authorization': `Bearer ${this.config.token}`,
            'Accept': 'application/vnd.github.v3+json',
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ body: markdown }),
        });

        if (!response.ok) {
          throw new Error(`Failed to update comment: ${response.status}`);
        }

        const data = await response.json() as any;
        return {
          success: true,
          commentId: data.id,
          commentUrl: data.html_url,
        };
      } else {
        // Create new comment
        const response = await fetch(`${apiUrl}/issues/${this.config.prNumber}/comments`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${this.config.token}`,
            'Accept': 'application/vnd.github.v3+json',
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ body: markdown }),
        });

        if (!response.ok) {
          throw new Error(`Failed to create comment: ${response.status}`);
        }

        const data = await response.json() as any;
        return {
          success: true,
          commentId: data.id,
          commentUrl: data.html_url,
        };
      }
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  }

  /**
   * Find existing Parity comment on PR
   */
  private async findExistingComment(): Promise<{ id: number; body: string } | null> {
    const apiUrl = `https://api.github.com/repos/${this.config.owner}/${this.config.repo}`;
    
    try {
      const response = await fetch(
        `${apiUrl}/issues/${this.config.prNumber}/comments?per_page=100`,
        {
          headers: {
            'Authorization': `Bearer ${this.config.token}`,
            'Accept': 'application/vnd.github.v3+json',
          },
        }
      );

      if (!response.ok) return null;

      const comments = await response.json() as any[];
      
      for (const comment of comments) {
        if (comment.body?.includes(this.COMMENT_MARKER)) {
          return { id: comment.id, body: comment.body };
        }
      }
    } catch {
      // Ignore errors
    }

    return null;
  }

  // --------------------------------------------------------------------------
  // Helpers
  // --------------------------------------------------------------------------

  private calculateSummary(pages: PageResult[]): {
    total: number;
    critical: number;
    high: number;
    medium: number;
    low: number;
  } {
    const summary = { total: 0, critical: 0, high: 0, medium: 0, low: 0 };
    
    for (const page of pages) {
      for (const diff of page.result.differences) {
        summary.total++;
        summary[diff.severity]++;
      }
    }
    
    return summary;
  }

  private getScoreEmoji(score: number): string {
    if (score >= 95) return 'ðŸŸ¢';
    if (score >= 85) return 'ðŸŸ¡';
    if (score >= 70) return 'ðŸŸ ';
    return 'ðŸ”´';
  }

  private formatDifference(diff: VisualDifference): string {
    const severityEmoji = {
      critical: 'ðŸ”´',
      high: 'ðŸŸ ',
      medium: 'ðŸŸ¡',
      low: 'âšª',
    }[diff.severity];

    let text = `- ${severityEmoji} **${diff.type}** (${diff.severity}): ${diff.description}\n`;
    
    if (diff.element) {
      text += `  - Element: \`${diff.element}\`\n`;
    }
    
    if (diff.figmaValue && diff.liveValue) {
      text += `  - Expected: \`${diff.figmaValue}\` â†’ Actual: \`${diff.liveValue}\`\n`;
    }
    
    if (diff.suggestion) {
      text += `  - ðŸ’¡ *${diff.suggestion}*\n`;
    }

    return text;
  }
}

// ============================================================================
// Factory
// ============================================================================

export function createPRCommentGenerator(config: CommentConfig): PRCommentGenerator {
  return new PRCommentGenerator(config);
}
